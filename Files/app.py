{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "6730d1ed-8634-429a-98bf-75ff90f49e2d",
   "metadata": {},
   "outputs": [],
   "source": [
    "import os\n",
    "import math\n",
    "import pandas as pd\n",
    "import numpy as np\n",
    "import streamlit as st\n",
    "from datetime import datetime, timedelta\n",
    "from typing import Optional, List\n",
    "from sqlalchemy import create_engine, text\n",
    "from sqlalchemy.engine import Engine\n",
    "from geopy.geocoders import Nominatim\n",
    "from geopy.extra.rate_limiter import RateLimiter\n",
    "import folium\n",
    "from streamlit_folium import st_folium"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "91b4faba-6355-41dc-a2c4-520d01f1cedc",
   "metadata": {},
   "outputs": [],
   "source": [
    "DB_URL = os.environ.get(\"WATERTRUCK_DB_URL\", \"sqlite:///watertruck.db\")\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "cefbd837-19f1-4870-b208-947d498d8802",
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "2025-11-03 20:26:22.283 \n",
      "  \u001b[33m\u001b[1mWarning:\u001b[0m to view this Streamlit app on a browser, run it with the following\n",
      "  command:\n",
      "\n",
      "    streamlit run C:\\Users\\aidan\\Annaconda\\Lib\\site-packages\\ipykernel_launcher.py [ARGUMENTS]\n"
     ]
    }
   ],
   "source": [
    "@st.cache_resource\n",
    "def get_engine() -> Engine:\n",
    "    engine = create_engine(DB_URL, future=True)\n",
    "    with engine.begin() as conn:\n",
    "        conn.exec_driver_sql(\n",
    "        \"\"\"\n",
    "        CREATE TABLE IF NOT EXISTS customers (\n",
    "            id INTEGER PRIMARY KEY AUTOINCREMENT,\n",
    "            name TEXT NOT NULL,\n",
    "            address TEXT NOT NULL,\n",
    "            phone TEXT,\n",
    "            latitude REAL,\n",
    "            longitude REAL,\n",
    "            last_filled DATE,\n",
    "            avg_interval_days REAL,\n",
    "            notes TEXT\n",
    "        );\n",
    "        \"\"\"\n",
    "        )\n",
    "        conn.exec_driver_sql(\n",
    "            \"\"\"\n",
    "            CREATE TABLE IF NOT EXISTS fills (\n",
    "                id INTEGER PRIMARY KEY AUTOINCREMENT,\n",
    "                customer_id INTEGER NOT NULL,\n",
    "                filled_at DATE NOT NULL,\n",
    "                gallons REAL,\n",
    "                FOREIGN KEY(customer_id) REFERENCES customers(id)\n",
    "            );\n",
    "            \"\"\"\n",
    "        )\n",
    "    return engine\n",
    "\n",
    "engine = get_engine()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": None,
   "id": "4ca2a643-22ea-4309-ab25-fc6c07868869",
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "85191877-a798-47e1-b422-abe3de3dce9f",
   "metadata": {},
   "outputs": [
    {
     "ename": "IndentationError",
     "evalue": "expected an indented block after function definition on line 3 (1473275414.py, line 4)",
     "output_type": "error",
     "traceback": [
      "\u001b[1;36m  Cell \u001b[1;32mIn[7], line 4\u001b[1;36m\u001b[0m\n\u001b[1;33m    geolocator = Nominatim(user_agent=\"watertruck_mvp\")\u001b[0m\n\u001b[1;37m    ^\u001b[0m\n\u001b[1;31mIndentationError\u001b[0m\u001b[1;31m:\u001b[0m expected an indented block after function definition on line 3\n"
     ]
    }
   ],
   "source": [
    "# ---------- Utilities ----------\n",
    "@st.cache_resource\n",
    "def geocoder():\n",
    "geolocator = Nominatim(user_agent=\"watertruck_mvp\")\n",
    "return RateLimiter(geolocator.geocode, min_delay_seconds=1)\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "def geocode_address(addr: str):\n",
    "try:\n",
    "loc = geocoder()(addr)\n",
    "if loc:\n",
    "return loc.latitude, loc.longitude\n",
    "except Exception:\n",
    "pass\n",
    "return None, None\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "def add_customer(name: str, address: str, phone: str, last_filled: Optional[datetime], notes: str):\n",
    "lat, lon = geocode_address(address)\n",
    "with engine.begin() as conn:\n",
    "conn.execute(\n",
    "text(\n",
    "\"INSERT INTO customers(name,address,phone,latitude,longitude,last_filled,avg_interval_days,notes)\\n VALUES(:n,:a,:p,:lat,:lon,:lf,:avg,:notes)\"\n",
    "),\n",
    "{\n",
    "\"n\": name,\n",
    "\"a\": address,\n",
    "\"p\": phone,\n",
    "\"lat\": lat,\n",
    "\"lon\": lon,\n",
    "\"lf\": last_filled.date() if last_filled else None,\n",
    "\"avg\": None,\n",
    "\"notes\": notes,\n",
    "},\n",
    ")\n",
    "\n",
    "def update_customer(cid: int, **fields):\n",
    "keys = [k for k, v in fields.items() if v is not None]\n",
    "if not keys:\n",
    "return\n",
    "set_clause = \", \".join([f\"{k}=:{k}\" for k in keys])\n",
    "params = {k: fields[k] for k in keys}\n",
    "params[\"id\"] = cid\n",
    "with engine.begin() as conn:\n",
    "conn.execute(text(f\"UPDATE customers SET {set_clause} WHERE id=:id\"), params)\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "def record_fill(customer_id: int, filled_at: datetime, gallons: Optional[float] = None):\n",
    "with engine.begin() as conn:\n",
    "conn.execute(\n",
    "text(\n",
    "\"INSERT INTO fills(customer_id, filled_at, gallons) VALUES(:cid,:dt,:gal)\"\n",
    "),\n",
    "{\"cid\": customer_id, \"dt\": filled_at.date(), \"gal\": gallons},\n",
    ")\n",
    "# also update customer's last_filled\n",
    "conn.execute(\n",
    "text(\"UPDATE customers SET last_filled=:dt WHERE id=:cid\"),\n",
    "{\"cid\": customer_id, \"dt\": filled_at.date()},\n",
    ")\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "def fetch_df(query: str, **params) -> pd.DataFrame:\n",
    "with engine.begin() as conn:\n",
    "df = pd.read_sql_query(text(query), conn, params=params)\n",
    "return df"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "4e8c0d50-d17a-4c3f-80da-675586f5bacc",
   "metadata": {},
   "outputs": [],
   "source": [
    "# ---------- Prediction logic ----------\n",
    "# Simple approach: use historical intervals per customer (median of deltas). If <2 fills, fall back to global median.\n",
    "\n",
    "\n",
    "def compute_intervals(customer_id: int) -> List[int]:\n",
    "    fills = fetch_df(\n",
    "        \"SELECT filled_at FROM fills WHERE customer_id=:cid ORDER BY filled_at ASC\",\n",
    "        cid=customer_id,\n",
    "    )\n",
    "    if len(fills) < 2:\n",
    "        return []\n",
    "    days = pd.to_datetime(fills[\"filled_at\"]).diff().dropna().dt.days.astype(int)\n",
    "    return days.tolist()\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "def global_median_interval() -> Optional[float]:\n",
    "    all_deltas = []\n",
    "    custs = fetch_df(\"SELECT id FROM customers\")\n",
    "    for cid in custs[\"id\"].tolist():\n",
    "        all_deltas += compute_intervals(cid)\n",
    "    if not all_deltas:\n",
    "        return None\n",
    "    return float(np.median(all_deltas))\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "def next_due_date_for_customer(row: pd.Series, today: datetime) -> (Optional[datetime], Optional[float]):\n",
    "    cid = int(row[\"id\"])\n",
    "    intervals = compute_intervals(cid)\n",
    "    if intervals:\n",
    "        interval = float(np.median(intervals))\n",
    "    else:\n",
    "        interval = row.get(\"avg_interval_days\") or global_median_interval() or 14.0 # default 2 weeks\n",
    "    last = row[\"last_filled\"]\n",
    "    if pd.isna(last):\n",
    "    # If never filled, mark as unknown; use today + interval as guess\n",
    "        due = today + timedelta(days=int(round(interval)))\n",
    "    else:\n",
    "        due = pd.to_datetime(last) + timedelta(days=int(round(interval)))\n",
    "    # Risk score grows as due approaches/passes (0 to 1+)\n",
    "    days_over = (today - pd.to_datetime(due)).days\n",
    "    risk = 1 / (1 + math.exp(-days_over / max(3.0, interval / 6))) # logistic\n",
    "    return due, float(risk)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": None,
   "id": "b82428d8-f4c7-4552-a659-5f91e9db080a",
   "metadata": {},
   "outputs": [],
   "source": [
    "# ---------- UI ----------\n",
    "st.set_page_config(page_title=\"Water Truck Dispatch\", page_icon=\"üöö\", layout=\"wide\")\n",
    "st.title(\"üöö Water Truck ‚Äì Customers, Map & Refill Predictions\")\n",
    "\n",
    "\n",
    "with st.sidebar:\n",
    "    st.header(\"Add / Update Customer\")\n",
    "    name = st.text_input(\"Name\")\n",
    "    address = st.text_area(\"Address\")\n",
    "    phone = st.text_input(\"Phone\")\n",
    "    last_filled = st.date_input(\"Last filled (optional)\", value=None)\n",
    "    notes = st.text_area(\"Notes\", height=80)\n",
    "    if st.button(\"‚ûï Add customer\"):\n",
    "        add_customer(name, address, phone, pd.to_datetime(last_filled) if last_filled else None, notes)\n",
    "        st.success(\"Customer added. Geocoding may take a moment.\")\n",
    "\n",
    "\n",
    "    st.divider()\n",
    "    st.header(\"Record Fill\")\n",
    "    custs = fetch_df(\"SELECT id, name FROM customers ORDER BY name\")\n",
    "    if not custs.empty:\n",
    "        selected = st.selectbox(\"Customer\", custs[\"name\"].tolist())\n",
    "        cid = int(custs[custs[\"name\"] == selected][\"id\"].iloc[0])\n",
    "        dt = st.date_input(\"Fill date\", value=datetime.today())\n",
    "        gallons = st.number_input(\"Gallons (optional)\", min_value=0.0, step=100.0, value=0.0)\n",
    "    if st.button(\"üßæ Save fill\"):\n",
    "        record_fill(cid, pd.to_datetime(dt), gallons if gallons > 0 else None)\n",
    "        st.success(\"Fill recorded and last date updated.\")\n",
    "\n",
    "# Tabs\n",
    "_tab1, _tab2, _tab3 = st.tabs([\"Customers\", \"Map\", \"Predictions\"])\n",
    "\n",
    "\n",
    "with _tab1:\n",
    "    st.subheader(\"Customers\")\n",
    "    df = fetch_df(\"SELECT * FROM customers ORDER BY name\")\n",
    "    st.dataframe(df, use_container_width=True)\n",
    "\n",
    "\n",
    "with _tab2:\n",
    "    st.subheader(\"Customer Map\")\n",
    "    df = fetch_df(\"SELECT id,name,address,latitude,longitude,last_filled FROM customers\")\n",
    "    # Center map: average lat/lon of known points, else default to Austin, TX\n",
    "    if not df.empty and df[\"latitude\"].notna().any():\n",
    "        center_lat = df[\"latitude\"].dropna().mean()\n",
    "        center_lon = df[\"longitude\"].dropna().mean()\n",
    "    else:\n",
    "        center_lat, center_lon = 30.2672, -97.7431\n",
    "\n",
    "\n",
    "    m = folium.Map(location=[center_lat, center_lon], zoom_start=10)\n",
    "    for _, r in df.iterrows():\n",
    "        if pd.notna(r[\"latitude\"]) and pd.notna(r[\"longitude\"]):\n",
    "            popup = f\"<b>{r['name']}</b><br>{r['address']}<br>Last filled: {r['last_filled']}\"\n",
    "            folium.Marker([r[\"latitude\"], r[\"longitude\"]], popup=popup).add_to(m)\n",
    "\n",
    "\n",
    "    st_folium(m, height=520, width=None)\n",
    "\n",
    "\n",
    "with _tab3:\n",
    "    st.subheader(\"Predicted Next Fills\")\n",
    "    today = datetime.today()\n",
    "    df = fetch_df(\"SELECT * FROM customers ORDER BY name\")\n",
    "    if df.empty:\n",
    "        st.info(\"No customers yet.\")\n",
    "    else:\n",
    "        df[\"due_date\"], df[\"risk_score\"] = zip(*df.apply(lambda r: next_due_date_for_customer(r, today), axis=1))\n",
    "        df[\"days_until_due\"] = (pd.to_datetime(df[\"due_date\"]) - today).dt.days\n",
    "        df_sorted = df.sort_values([\"risk_score\", \"days_until_due\"], ascending=[False, True])\n",
    "        st.dataframe(df_sorted[[\"name\",\"address\",\"phone\",\"last_filled\",\"due_date\",\"days_until_due\",\"risk_score\"]], use_container_width=True)\n",
    "        st.caption(\"Risk score ~ how urgent a refill is (higher ‚Üí more urgent).\")\n",
    "        \n",
    "    \n",
    "        st.download_button(\n",
    "            label=\"‚¨áÔ∏è Export schedule (CSV)\",\n",
    "            data=df_sorted[[\"name\",\"address\",\"phone\",\"due_date\",\"days_until_due\",\"risk_score\"]].to_csv(index=False),\n",
    "            file_name=f\"refill_schedule_{today.date()}.csv\",\n",
    "            mime=\"text/csv\",\n",
    "        )"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": None,
   "id": "865f0a5e-d762-43c1-b6b3-a432be7de22b",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.4"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
